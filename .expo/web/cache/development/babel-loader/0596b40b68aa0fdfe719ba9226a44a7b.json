{"ast":null,"code":"import flattenStyle from \"./flattenStyle\";\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\nfunction notNull(value) {\n  return value !== null;\n}\n\nfunction parsePosition(value) {\n  if (value === 'from') {\n    return 0;\n  }\n\n  if (value === 'to') {\n    return 1;\n  }\n\n  var parsed = parseFloat(value, 10);\n\n  if (Number.isNaN(parsed) || parsed < 0 || parsed > 1) {\n    return null;\n  }\n\n  return parsed;\n}\n\nvar cache = {};\nexport default function createAnimation(definition) {\n  var cacheKey = JSON.stringify(definition);\n\n  if (cache[cacheKey]) {\n    return cache[cacheKey];\n  }\n\n  var positions = Object.keys(definition).map(parsePosition).filter(notNull);\n  positions.sort(compareNumbers);\n\n  if (positions.length < 2) {\n    throw new Error('Animation definitions must have at least two values.');\n  }\n\n  var compiled = {};\n\n  if (definition.easing) {\n    compiled.easing = definition.easing;\n  }\n\n  if (definition.style) {\n    compiled.style = definition.style;\n  }\n\n  var _loop = function _loop(i) {\n    var position = positions[i];\n    var keyframe = definition[position];\n\n    if (!keyframe) {\n      if (position === 0) {\n        keyframe = definition.from;\n      } else if (position === 1) {\n        keyframe = definition.to;\n      }\n    }\n\n    if (!keyframe) {\n      throw new Error('Missing animation keyframe, this should not happen');\n    }\n\n    keyframe = flattenStyle(keyframe);\n    Object.keys(keyframe).forEach(function (key) {\n      if (!(key in compiled)) {\n        compiled[key] = {\n          inputRange: [],\n          outputRange: []\n        };\n      }\n\n      compiled[key].inputRange.push(position);\n      compiled[key].outputRange.push(keyframe[key]);\n    });\n  };\n\n  for (var i = 0; i < positions.length; i += 1) {\n    _loop(i);\n  }\n\n  cache[cacheKey] = compiled;\n  return compiled;\n}","map":{"version":3,"sources":["C:/www/CyberBunker/node_modules/react-native-animatable/createAnimation.js"],"names":["flattenStyle","compareNumbers","a","b","notNull","value","parsePosition","parsed","parseFloat","Number","isNaN","cache","createAnimation","definition","cacheKey","JSON","stringify","positions","Object","keys","map","filter","sort","length","Error","compiled","easing","style","i","position","keyframe","from","to","forEach","key","inputRange","outputRange","push"],"mappings":"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","sourcesContent":["import flattenStyle from './flattenStyle';\r\n\r\nfunction compareNumbers(a, b) {\r\n  return a - b;\r\n}\r\n\r\nfunction notNull(value) {\r\n  return value !== null;\r\n}\r\n\r\nfunction parsePosition(value) {\r\n  if (value === 'from') {\r\n    return 0;\r\n  }\r\n  if (value === 'to') {\r\n    return 1;\r\n  }\r\n  const parsed = parseFloat(value, 10);\r\n  if (Number.isNaN(parsed) || parsed < 0 || parsed > 1) {\r\n    return null;\r\n  }\r\n  return parsed;\r\n}\r\n\r\nconst cache = {};\r\n\r\nexport default function createAnimation(definition) {\r\n  const cacheKey = JSON.stringify(definition);\r\n  if (cache[cacheKey]) {\r\n    return cache[cacheKey];\r\n  }\r\n\r\n  const positions = Object.keys(definition)\r\n    .map(parsePosition)\r\n    .filter(notNull);\r\n  positions.sort(compareNumbers);\r\n\r\n  if (positions.length < 2) {\r\n    throw new Error('Animation definitions must have at least two values.');\r\n  }\r\n\r\n  const compiled = {};\r\n  if (definition.easing) {\r\n    compiled.easing = definition.easing;\r\n  }\r\n  if (definition.style) {\r\n    compiled.style = definition.style;\r\n  }\r\n\r\n  for (let i = 0; i < positions.length; i += 1) {\r\n    const position = positions[i];\r\n    let keyframe = definition[position];\r\n    if (!keyframe) {\r\n      if (position === 0) {\r\n        keyframe = definition.from;\r\n      } else if (position === 1) {\r\n        keyframe = definition.to;\r\n      }\r\n    }\r\n    if (!keyframe) {\r\n      throw new Error('Missing animation keyframe, this should not happen');\r\n    }\r\n\r\n    keyframe = flattenStyle(keyframe);\r\n    Object.keys(keyframe).forEach(key => {\r\n      if (!(key in compiled)) {\r\n        compiled[key] = {\r\n          inputRange: [],\r\n          outputRange: [],\r\n        };\r\n      }\r\n      compiled[key].inputRange.push(position);\r\n      compiled[key].outputRange.push(keyframe[key]);\r\n    });\r\n  }\r\n\r\n  cache[cacheKey] = compiled;\r\n\r\n  return compiled;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}